# 面试题 08.11. 硬币
# 硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)

# 示例1:

#  输入: n = 5
#  输出：2
#  解释: 有两种方式可以凑成总金额:
# 5=5
# 5=1+1+1+1+1
# 示例2:

#  输入: n = 10
#  输出：4
#  解释: 有四种方式可以凑成总金额:
# 10=10
# 10=5+5
# 10=5+1+1+1+1+1
# 10=1+1+1+1+1+1+1+1+1+1
# 说明：

# 注意:

# 你可以假设：

# 0 <= n (总金额) <= 1000000


# 币值为25分、10分、5分和1分
class Solution:
####### 正确解法 ########
#### 这是组合问题，千万注意避免因为顺序不同而产生的重复计数
## 于是我们先遍历硬币，保证在考虑一枚硬币的情况时，没有较大的硬币影响，
## 这样，我们最终每种组合情况，都是以硬币的面额大小非递减组合。保证了同样的情况，调换顺序后重复计算的情况。

    # 动态规划
    ## dp[n]保存n分有几种表示方式
    def waysToChange(self, n: int) -> int:
        if n == 0:
            return 0
        dp = [0] * (n + 1)
        dp[0] = 1
        coin_list = [1, 5, 10, 25]
        for coin in coin_list:
            for i in range(coin, n + 1):
                dp[i] += dp[i - coin]
        return dp[n] % 1000000007

####### !!!!!!!!!!错误解法！！！！！！！！#######
## 因顺序不同产生了重复
    def waysToChange(self, n: int) -> int:
        if n == 0:
            return 0
        dp = [0] * (n + 1)
        dp[0], dp[1] = 1, 1
        coin_list = [1, 5, 10, 25]
        for i in range(2, n + 1):
            for value in coin_list:
                if i - value >= 0:
                    dp[i] += dp[i - value]
                else:
                    break
        return dp[n]
## ！！！错误分析：
# 前面5种情况数：dp[1,5] = [1,1,1,1,2];

# coin = 1:
# dp[6] += (dp[6 - coin] => dp[5] => 2);
# 即拿到coin(1)的情况有两种 :
# 	coin(1,1,1,1,1) + coin(1);
# 	coin(5) + coin(1);
	
# coin = 5:
# dp[6] += (dp[6 - coin] => dp[1] => 1);
# 即拿到coin（5）的情况有一种:
# 	coin(1) + coin(5);
# 但是事实却是 6 的情况只有两种，（1，1，1，1，1，1）和（1，5）。这里是把（1，5）和（5，1）前后顺序不同的情况重复算了 1 次。因此我们应该去考虑硬币顺序带来的影响。

