# **关于数组的算法**

## **1. 如何写出正确的程序**

**技巧**：

   > 1. 明确变量的含义，在写代码时要注意维护该含义（即维持循环不变量，变量的值会发生改变，但变量的含义不能改变）（观察，思考）
   >2. 考虑各种边界情况/特殊情况，比如待查找的数据集是空集，待查找的值不在数据集中，...
   >3. 小数据量调试(耐心)
   >4. 大数据量测试


**举例：二分查找法**

- 在$[l, r]$的范围寻找target

    <img style="width:400px;height:200px" src = "./images/binary_search1.png" >
  
- 在$[l, r)$的范围寻找target
  
    <img style="width:400px;height:200px" src = "./images/binary_search2.png" >

- **注意**：整型溢出
  
        mid = (l + r)/2

    因为l和r都是int型，当它们很大时，在做加法运算可能会出现整型溢出，C++中整型溢出是不报错的。

**实战:**

**1. leetcode 283 移动零**

**(1). 直接的想法**

   ```python
   def move_zeros(nums):
      new_nums = []
      n = len(nums)
      for i in range(n):
            if nums[i]:
               new_nums.append(nums[i])
      m = len(new_nums)
      for i in range(m):
            nums[i] = new_nums[i]
      for i in range(m, n):
            nums[i] = 0
   ```

   时间复杂度：$O(n)$

   空间复杂度：$O(n)$

**(2). 优化**

   >不需要使用额外的数组保存非0元素；  
   >[0,k)区间保存所有当前遍历过的非0元素；
   > 1. 初始时 k = 0，扫描原数组(i 标志扫描)，遇到非0元素就放在原数组k位置上，k ++ ，使得原数组[0,k)区间保存非0元素；
   > 2. 扫描完 (i == len(nums)), 将nums[k,len(n-1))范围内的数置0；

   ```python
   def move_zero(nums):
      k = 0
   ```

   时间复杂度：$O(n)$

   空间复杂度：$O(1)$

**(3). 优化**

   > 不需要方法2中的步骤2，在扫描到非0元素时，将非0元素和0原色交换；

   ```python

   ```


**2. leetcode 27 删除元素**

```
```

**3. leectode 26 删除数组中重复的元素**

```
```

**4. leetcode 80 删除数组中重复的元素II**

```
```

## **3. 基础算法思路的应用**

### **3.1 leetcode 75 sort colors**

  >给定一个有n个元素的数组，数组中元素的取值只有0，1，2三种可能，为这个数组排序

  (1) 暴力方法

     时间复杂度：$O(n^2)$

  (2) 计数排序

   >**思路**：分别统计0，1，2的元素个数，然后依次将多少个0，多少个1，多少个2放回数组

   代码：

   ```python


   ```

   时间复杂度：$O(n)$

   空间复杂度：$O(1)$

   遍历了整个数组2遍

  (3) 三路排序

   >**思路**：设置索引`zero`，`two`，希望`nums[0,...zero] == 0, nums[zero + 1, two - 1]== 1, nums[two, n-1] == 2`, 初始值设置`zero = -1`，`two = n` （n是数组的大小）

   代码：

   ```python
   ```

   时间复杂度：$O(n)$

   空间复杂度：$O(1)$

   遍历了整个数组1遍

### **3.2 练习题**

  - leetcode 88 merge sorted array
  
    ```python
    ```

  - leetcode 215 kth lagest element in an arraray
  
    ```python
    # 利用快排partition中，将pivot放置在了其正确的位置上的性质
    ```

- leetcode 167 two sum II — input array is sorted
   1. 暴力解法

        ```python
        # 双层遍历
        ```

      时间复杂度：$O(n^2)$

   2. 二分搜索

      >**思路**： 充分利用原数组的性质——有序。依次遍历每一个数据`nums[i]`, 对于每一个`nums[i]`在剩余的数组中使用二分查找的思路来寻找`target - nums[i]`, 如果找到了的话，就找到了两个数相加结果为`target`,否则继续往后遍历。

      代码：

      ```python
      ```

      时间复杂度：$O(nlogn)$


# 3-7

## 双索引技术

  定义好两个索引的含义，使用一定的规则去移动它们。

  1. **对撞指针**

     >前面的例子中两个指针向相对的方向行进，在这个过程中就可能找到我们要求解的答案。

  2. **滑动窗口**

     >两个索引构成一个窗口，让这个窗口不停地滑动，来在数组中找到要求解的答案。
  
- **例题** leetcode 209 minimum size subarray sum

   (1) **暴力解**

   **思路**：遍历所有的连续子数组$[i,...,j]$,
      计算其和`sum`,验证`sum >= s`,时间复杂度为$O(n^3)$
   ```python
   ```
   (2) **优化暴力解**

   **思路**：优化暴力解中的求和`sum`的过程，时间复杂度$O(n^2)$

   (3) **滑动窗口**
  ```python
   def min_sub_array_len(s, nums):
   l = 0
   r = -1 # nums[l,...,r]为滑动窗口
   sum = 0 # 初始时候，nums[0,-1]范围内没有数，sum=0
   n = len(nums)
   res = n + 1
   while l < n:
      if r + 1 < n and sum < s:
         r += 1
         sum += nums[r]
      else:
         sum -= nums[l]
         l += 1
      if sum >= s:
         res = min(res, r - l + 1)
   if res == n + 1:
      return 0
   else:
      return res
  ```
# 3-8

- **leetcode 3 longest substring without repeating characters**
  **题目描述**: 
   > 3 . 无重复字符的最长子串
   给定一个字符串,请你找出其中不含有重复字符的最长子串的长度。
   示例:
   输入: "abcabcbb"
   输出: 3 
   解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
  
  **思路分析**：使用滑动窗口遍历子串；使用freq数组记录子串中字符出现次数，判断是否有重复字符时只用查询freq[i]是否为1，为1表示子串中已经有该字符。（i是查询字符的ASII码）

  **代码**：
  ```python
   ## 使用滑动窗口
   ## 注意python中字符转换为ASCII码要使用ord(),
   ## 不能用int(),int()只能将数字字符转换为对应的整数
   def lengthOfLongestSubstring(s):
      l = 0
      r = -1 # s[l,r]范围内保存不重复子串
      freq = [0 for i in range(256)] # 保存字符在子串中出现的次数，索引为字符的scii值
      res = 0
      while l < len(s):
         if r + 1 < len(s) and freq[ord(s[r + 1])] == 0:
               r += 1
               freq[ord(s[r])] += 1
         else:
               freq[ord(s[l])] -= 1
               l += 1
         res = max(res, r - l + 1)
      return res
  ```

- **练习题**
  438 76 
